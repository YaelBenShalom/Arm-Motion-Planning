#!/usr/bin/env python3

import sys
import copy
import rospy
import arm_move
import moveit_commander
from arm_move.srv import Step
from std_srvs.srv import Empty, EmptyResponse
from geometry_msgs.msg import Pose
import unittest

class ArmTest(unittest.TestCase):
    def __init__(self, *args, **kwargs):
        super(ArmTest, self).__init__(*args, **kwargs)
        rospy.init_node('arm_test')

    def test_reset_and_step(self):
        """ Function to check the returned error code value of 'step' service
        with an impossible waypoint
        """
        rospy.loginfo(f"before reset")
        rospy.wait_for_service('/px100/reset')
        reset = rospy.ServiceProxy('/px100/reset', Empty)
        rospy.loginfo(f"before reset call")
        reset() # Calling the reset service
        rospy.loginfo(f"after reset")
        
        step_msg = Step()
        pose_goal = Pose()
        pose_goal.orientation.w = 1.0
        pose_goal.position.x = 0.1
        pose_goal.position.y = 0
        pose_goal.position.z = -0.2 # This coordinate makes the robot crash into the floor
        step_msg.gripper = False
        step_msg.pose = copy.deepcopy(pose_goal)

        rospy.wait_for_service('/px100/step')
        step = rospy.ServiceProxy('/px100/step', Step)
        error_code = step.call(step_msg.pose, step_msg.gripper) # Calling the step service
        rospy.loginfo(f"error_code: {error_code}")

        result = False
        if (error_code == -1): # The service should return an error code
            result = True
        self.assertTrue(True) # The test pass

if __name__ == "__main__":
    # unittest.main() doesn't start roscore
    import rostest
    rostest.rosrun('arm_move', 'arm_test', ArmTest)